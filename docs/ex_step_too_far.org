# -*- Mode:Org; Coding:utf-8; fill-column:158 -*-
# ######################################################################################################################################################.H.S.##
# FILE:        ex_step_too_far.org
#+TITLE:       Runge-Kutta Step Size and Accuracy
#+SUBTITLE:    A MRKISS Library Example Program
#+AUTHOR:      Mitch Richling
#+EMAIL:       http://www.mitchr.me/
#+DESCRIPTION: MRKISS Documentation Examples
#+KEYWORDS:    RK runge kutta ode ivp
#+LANGUAGE:    en
#+OPTIONS:     num:t toc:nil \n:nil @:t ::t |:t ^:nil -:t f:t *:t <:t skip:nil d:nil todo:t pri:nil H:5 p:t author:t html-scripts:nil 
# FIXME: When uncommented the following line will render latex equations as images embedded into exported HTML, when commented MathJax will be used
# #+OPTIONS:     tex:dvipng
# FIXME: Select ONE of the three TODO lines below
# #+SEQ_TODO:    ACTION:NEW(t!) ACTION:ASSIGNED(a!@) ACTION:WORK(w!) ACTION:HOLD(h@) | ACTION:FUTURE(f) ACTION:DONE(d!) ACTION:CANCELED(c!)
# #+SEQ_TODO:    TODO:NEW(T!)                        TODO:WORK(W!)   TODO:HOLD(H@)   |                  TODO:DONE(D!)   TODO:CANCELED(C!)
#+SEQ_TODO:    TODO:NEW(t)                         TODO:WORK(w)    TODO:HOLD(h)    | TODO:FUTURE(f)   TODO:DONE(d)    TODO:CANCELED(c)
#+PROPERTY: header-args :eval never-export
#+HTML_HEAD: <style>body { width: 95%; margin: 2% auto; font-size: 18px; line-height: 1.4em; font-family: Georgia, serif; color: black; background-color: white; }</style>
# Change max-width to get wider output -- also note #content style below
#+HTML_HEAD: <style>body { min-width: 500px; max-width: 1024px; }</style>
#+HTML_HEAD: <style>h1,h2,h3,h4,h5,h6 { color: #A5573E; line-height: 1em; font-family: Helvetica, sans-serif; }</style>
#+HTML_HEAD: <style>h1,h2,h3 { line-height: 1.4em; }</style>
#+HTML_HEAD: <style>h1.title { font-size: 3em; }</style>
#+HTML_HEAD: <style>.subtitle { font-size: 0.6em; }</style>
#+HTML_HEAD: <style>h4,h5,h6 { font-size: 1em; }</style>
#+HTML_HEAD: <style>.org-src-container { border: 1px solid #ccc; box-shadow: 3px 3px 3px #eee; font-family: Lucida Console, monospace; font-size: 80%; margin: 0px; padding: 0px 0px; position: relative; }</style>
#+HTML_HEAD: <style>.org-src-container>pre { line-height: 1.2em; padding-top: 1.5em; margin: 0.5em; background-color: #404040; color: white; overflow: auto; }</style>
#+HTML_HEAD: <style>.org-src-container>pre:before { display: block; position: absolute; background-color: #b3b3b3; top: 0; right: 0; padding: 0 0.2em 0 0.4em; border-bottom-left-radius: 8px; border: 0; color: white; font-size: 100%; font-family: Helvetica, sans-serif;}</style>
#+HTML_HEAD: <style>pre.example { white-space: pre-wrap; white-space: -moz-pre-wrap; white-space: -o-pre-wrap; font-family: Lucida Console, monospace; font-size: 80%; background: #404040; color: white; display: block; padding: 0em; border: 2px solid black; }</style>
#+HTML_HEAD: <style>blockquote { margin-bottom: 0.5em; padding: 0.5em; background-color: #FFF8DC; border-left: 2px solid #A5573E; border-left-color: rgb(255, 228, 102); display: block; margin-block-start: 1em; margin-block-end: 1em; margin-inline-start: 5em; margin-inline-end: 5em; } </style>
# Change the following to get wider output -- also note body style above
#+HTML_HEAD: <style>#content { max-width: 60em; }</style>
#+HTML_LINK_HOME: https://www.mitchr.me/
#+HTML_LINK_UP: https://github.com/richmit/MRKISS/
# ######################################################################################################################################################.H.E.##

#+ATTR_HTML: :border 2 solid #ccc :frame hsides :align center
|          <r> | <l>                                          |
|    *Author:* | /{{{author}}}/                               |
|   *Updated:* | /{{{modification-time(%Y-%m-%d %H:%M:%S)}}}/ |
| *Generated:* | /{{{time(%Y-%m-%d %H:%M:%S)}}}/              |
#+ATTR_HTML: :align center
Copyright \copy {{{time(%Y)}}} Mitch Richling. All rights reserved.

#+TOC: headlines 2

#        #         #         #         #         #         #         #         #         #         #         #         #         #         #         #         #
#        #         #         #         #         #         #         #         #         #         #         #         #         #         #         #         #         #         #         #         #         #         #         #         #         #         #         #         #         #
#   010  #    020  #    030  #    040  #    050  #    060  #    070  #    080  #    090  #    100  #    110  #    120  #    130  #    140  #    150  #    160  #    170  #    180  #    190  #    200  #    210  #    220  #    230  #    240  #    250  #    260  #    270  #    280  #    290  #
# 345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890
#        #         #         #         #         #         #         #         #         #         #         #         #         #         #         #       | #         #         #         #         #         #         #         #         #         #         #         #         #         #
#        #         #         #         #         #         #         #         #         #         #         #         #         #         #         #       | #         #         #         #         #         #         #         #         #         #         #         #         #         #

* Results
:PROPERTIES:
:CUSTOM_ID: Results
:END:

The code for this example is found in [[https://github.com/richmit/MRKISS/blob/master/examples/step_too_far.f90][~examples/step_too_far.f90~]].
Additionally the code may be found at the end of this document in the section [[#full-code][Full Code Listing]].

#+begin_src sh :results output verbatum :exports results :wrap "org"
~/core/codeBits/bin/srcHdrInfo ../examples/step_too_far.f90
#+end_src

#+RESULTS:
#+begin_org
  In this example we solve a simple equation with various step sizes in order to observe the relationship between step size and
  accuracy.

  The system we solve:
     \[ y'(t)=e^t + y(t) \,\,\,\mathrm{with}\,\,\, y(0)=0 \]

  We can solve this equation symbolically:
     \[ y(t) = te^t  \]

  By construction, the truncation error for an RK method decreases as the step size decreases.  Round-off error on the other
  hand increases as the step size decreases.  Total error is the sum of truncation and round-off error.  In this experiment we
  directly measure total error.  For moderate step sizes we observe truncation error dominating the total error.  As the step
  size gets smaller, we see the total error continue to improve as expected; however, the nice smooth response curve begins to
  roughen up a bit with what looks like random noise.  Eventually we reach small enough step sizes that round-off error begins
  to dominate the results, and accuracy degrades as step size continues to decrease. The point at which this happens is very
  much dependent upon the RK method, the problem, and how the method is implemented.  This last point is important.  Simply
  rearranging the order of operations can have dramatic impact on final error.
#+end_org

Here is a log-log plot of our measured results:

#+ATTR_HTML: :width 90% :align center
file:pics/step_too_far.png

We can statistically decompose the total error into truncation and round-off components.  The results look 
something like this:

#+ATTR_HTML: :width 90% :align center
file:pics/step_too_far_mean.png

In the above graph notice the distinct difference between the behavior of truncation and round-off errors in terms of the residual distribution.  In
particular the variance is much higher for round-off residuals than truncation residuals.  While this is not always the case, it's a pretty common occurrence
in practice.

#+ATTR_HTML: :width 90% :align center
file:pics/step_too_far_trdst.png

The final value of \(t\) for a solution is a sum of \(\Delta{t}\) values, and will therefore be impacted by round-off errors.  For fixed step size algorithms
round-off errors may be greatly reduced by computing each \(t\) point as a product instead of a running sum.  Unfortunately adaptive algorithms don't provide
such a simple remedy.  Here is a glimpse of the impact of step size on \(t\) round-off:

#+ATTR_HTML: :width 90% :align center
file:pics/step_too_far_tfit.png

* Full Code Listing
:PROPERTIES:
:CUSTOM_ID: full-code
:END:

** Fortran Code
:PROPERTIES:
:CUSTOM_ID: fortrancode
:END:

#+begin_src sh :results output verbatum :exports results :wrap "src f90 :eval never :tangle no"
~/core/codeBits/bin/src2orgListing ../examples/step_too_far.f90
#+end_src

#+RESULTS:
#+begin_src f90 :eval never :tangle no
program step_too_far

  use :: mrkiss_config,          only: rk, istats_size
  use :: mrkiss_solvers_wt,      only: steps_fixed_stab
  use :: mrkiss_utils,           only: print_solution
  use :: mrkiss_erk_kutta_4,     only: a, b, c

  implicit none

  integer,        parameter :: deq_dim       = 1
  real(kind=rk),  parameter :: y_iv(deq_dim) = [0.0_rk]
  real(kind=rk),  parameter :: t_iv          = 0.0_rk
  real(kind=rk),  parameter :: param(1)      = [0.0_rk]
  real(kind=rk),  parameter :: t_end         = 1.0_rk

  real(kind=rk)             :: solution(1+2*deq_dim, 1)
  integer                   :: status, istats(istats_size), sso, num_pts
  logical                   :: fi

  fi = .true.
  do sso = 1000,2100
     num_pts = 1.005_rk ** sso
     print '("sso=",i4," num_pts=",i0)', sso, num_pts
     call steps_fixed_stab(status, istats, solution, eq, t_iv, y_iv, param, a, b, c, max_pts_o=num_pts, t_end_o=t_end)
     call print_solution(status, solution, filename_o="step_too_far.csv", tag_o=sso, prt_titles_o=fi, append_o=.not. fi)
     fi = .false.
  end do

contains

  subroutine eq(status, dydt, t, y, param)
    integer,          intent(out) :: status
    real(kind=rk),    intent(out) :: dydt(:)
    real(kind=rk),    intent(in)  :: t
    real(kind=rk),    intent(in)  :: y(:)
    real(kind=rk),    intent(in)  :: param(:)
    dydt = [ exp(t) + y(1) ]
    status = 0
  end subroutine eq

end program step_too_far
#+end_src

** R Code
:PROPERTIES:
:CUSTOM_ID: rcode
:END:

The images were produced with R.

#+begin_src sh :results output verbatum :exports results :wrap "src R :eval never :tangle no"
~/core/codeBits/bin/src2orgListing ../examples/step_too_far.R
#+end_src

#+RESULTS:
#+begin_src R :eval never :tangle no
solDat <- fread("step_too_far.csv") %>%
  mutate(errt   = abs(1-t),
         y      = y1,
         erryat = abs(y-exp(t)),
         erry   = abs(y-exp(1)),
         sso    = tag,
         pts    = 1.005^sso,
         delta  = 1/(pts-1)) %>% 
  filter(errt>0 & erryat>0 & erry>0)

# Plot the raw results.
gp <- ggplot(solDat) +
  geom_line( aes(x=delta, y=erry)) +
  scale_y_log10() +
  scale_x_log10() +
  labs(title='Accuracy: Step Size Vs. Total Error', 
       subtitle='Experimental results from RK4 ', x='Step Size', y='Total Error')
ggsave(filename='step_too_far.png', plot=gp, width=2*1024, height=1023, units='px', dpi=150)

# Compute the log transformed linear regression for the truncation error dominated part of the dataset
treDat <- solDat %>% 
  transmute(x=delta, y=erryat) %>% 
  filter(x>0 & y>0) %>% 
  mutate(xt=log(x), yt=log(y)) %>% 
  filter(x>1e-3)
treFit <- lm(yt ~ xt, data=treDat)     
treDat <- treDat %>% 
  mutate(yf=exp(coef(treFit)[1])*x^(coef(treFit)[2]))

# Note the value for 'xt' in the fit will be the order of the RK method used.  
# This is a practical way experimentally to compute the order for a RK method.
print(summary(treFit))

ggplot(data=treDat, aes(x=x)) +
  geom_line(aes(y=y), col='red') +
  geom_line(aes(y=yf), col='blue') +
  scale_y_log10() +
  scale_x_log10() 

# Compute the log transformed linear regression for the round-off error dominated part of the dataset
roeDat <- solDat %>% 
  transmute(x=delta, y=erryat) %>% 
  filter(x>0 & y>0) %>% 
  mutate(xt=log(x), yt=log(y)) %>% 
  filter(x<2e-4)
roeFit <- lm(yt ~ xt, data=roeDat)     
roeDat <- roeDat %>% 
  mutate(yf=exp(coef(roeFit)[1])*x^(coef(roeFit)[2]))

ggplot(data=roeDat, aes(x=x)) +
  geom_line(aes(y=y), col='red') +
  geom_line(aes(y=yf), col='blue') +
  scale_y_log10() +
  scale_x_log10() 

# Add total, truncation, round-off error to our solution data and plot everything.
solDat <- solDat %>% mutate(erryattre=exp(coef(treFit)[1])*delta^(coef(treFit)[2]),
                            erryatroe=exp(coef(roeFit)[1])*delta^(coef(roeFit)[2]),
                            erryattoe=erryattre+erryatroe)

gp <- ggplot(data=solDat, aes(x=delta)) +
  geom_line(aes(y=erryattre, col='Mean Truncation Error'), linewidth=5, alpha=0.7) +
  geom_line(aes(y=erryatroe, col='Mean Round-off Error'), linewidth=5, alpha=0.7) +
  geom_line(aes(y=erryattoe, col='Mean Total Error'), linewidth=3) +
  geom_point(aes(y=erryat, col='True Error'), size=0.5) +
  scale_y_log10(limits=range(solDat$erryat)) +
  scale_x_log10() +
  scale_colour_manual(name='Error Type', 
                      values=c('Mean Total Error'      = 'darkorchid3',
                               'Mean Truncation Error' = 'goldenrod',
                               'Mean Round-off Error'  = 'darkolivegreen3',                               
                               'True Error'            = 'indianred3')) +
  labs(title='Error Vs. Step Size', 
       subtitle='Experimental results from RK4 illustrating total error as a sum of round-off and truncation errors.', 
       x='Step Size', y='Errors')
ggsave(filename='step_too_far_mean.png', plot=gp, width=1024, height=600, units='px', dpi=100)

# Compute the log transformed linear regression for t
troeDat <- solDat %>% 
  transmute(x=delta, y=errt) %>% 
  filter(x>0 & y>0) %>% 
  mutate(xt=log(x), yt=log(y))
troeFit <- lm(yt ~ xt, data=troeDat)     
troeDat <- troeDat %>% 
  mutate(yf=exp(coef(troeFit)[1])*x^(coef(troeFit)[2]))

gp <- ggplot(data=troeDat, aes(x=x)) +
  geom_line(aes(y=yf, col='Mean Round-off Error'), alpha=0.7, linewidth=10) +
  geom_point(aes(y=y, col='True Error'), size=0.5) +
  scale_y_log10() +
  scale_x_log10() +
  scale_colour_manual(name='Error Type', 
                      values=c('Mean Round-off Error'  = 'darkolivegreen3',                               
                               'True Error'            = 'indianred3')) +
  labs(title='Independent Variable Error Vs. Step Size', 
       subtitle='Experimental results from RK4.', 
       x='Step Size', y='Errors')
ggsave(filename='step_too_far_tfit.png', plot=gp, width=1024, height=600, units='px', dpi=100)

#+end_src
