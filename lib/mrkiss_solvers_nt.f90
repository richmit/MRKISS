! -*- Mode:F90; Coding:us-ascii-unix; fill-column:129 -*-
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!.H.S.!!
!>
!! @file      mrkiss_solvers_nt.f90
!! @author    Mitch Richling http://www.mitchr.me/
!! @brief     RK Solvers.@EOL
!! @keywords  runge kutta embedded butcher tableau
!! @std       F2023
!! @see       https://github.com/richmit/MRKISS
!! @copyright 
!!  @parblock
!!  Copyright (c) 2025, Mitchell Jay Richling <http://www.mitchr.me/> All rights reserved.
!!  
!!  Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following
!!  conditions are met:
!!  
!!  1. Redistributions of source code must retain the above copyright notice, this list of conditions, and the following
!!     disclaimer.
!!  
!!  2. Redistributions in binary form must reproduce the above copyright notice, this list of conditions, and the following
!!     disclaimer in the documentation and/or other materials provided with the distribution.
!!  
!!  3. Neither the name of the copyright holder nor the names of its contributors may be used to endorse or promote products
!!     derived from this software without specific prior written permission.
!!  
!!  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
!!  INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
!!  DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
!!  EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF
!!  USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
!!  LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
!!  OF THE POSSIBILITY OF SUCH DAMAGE.
!!  @endparblock
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!.H.E.!!

! >>>>>>>>>>>>>>>>>>>>>>>>>>>>>> WARNING <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
! >>>>>>>>>>>>>>>>>>>>>>>>>>>>>> WARNING <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
! >>>>>>>>>>>>>>>>>>>>>>>>>>>>>> WARNING <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
!
! This file is GENERATED from mrkiss_solvers_wt.f90
! 
! Do NOT edit this file.  Instead edit mrkiss_solvers_wt.f90. Changes 
! will automatically be picked up via the makefile in examples/.
!
! >>>>>>>>>>>>>>>>>>>>>>>>>>>>>> WARNING <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
! >>>>>>>>>>>>>>>>>>>>>>>>>>>>>> WARNING <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
! >>>>>>>>>>>>>>>>>>>>>>>>>>>>>> WARNING <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
! 

!----------------------------------------------------------------------------------------------------------------------------------
!> Solvers.
!!
module mrkiss_solvers_nt
  implicit none
  private

  !--------------------------------------------------------------------------------------------------------------------------------
  !> Type for ODE dydt functions.
  !!
  !! status .................... Exit status
  !! status .................... Exit status
  !!                              - -inf-0 .... Everything worked
  !!                              - 1-255 ..... Error in this routine
  !!                              - others .... Other values are not allowed
  !! t ......................... Value for t.
  !! y(:) ...................... Value for y.
  !! param(:) .................. Data payload usually used for constants.
  !!
  abstract interface
     subroutine deq_iface_nt(status, dydt, y, param)
       use mrkiss_config, only: rk, ik
       implicit none
       integer(kind=ik), intent(out) :: status
       real(kind=rk),    intent(out) :: dydt(:)
       real(kind=rk),    intent(in)  :: y(:)
       real(kind=rk),    intent(in)  :: param(:)
     end subroutine deq_iface_nt
  end interface

  !--------------------------------------------------------------------------------------------------------------------------------
  !> Type step processing subroutine.
  !!
  !! status .................... Exit status
  !!                              - -inf-0 .... Everything worked
  !!                              - 256-511 ... Error in this routine
  !!                              - others .... Other values are not allowed
  !! t ......................... Value for t.
  !! y(:) ...................... Value for y.
  !! param(:) .................. Data payload usually used for constants.
  !!
  abstract interface
     subroutine stepp_iface_nt(status, end_run, sdf_flags, new_t_delta, pnt_idx, t_y_sol, t_delta, y_delta)
       use mrkiss_config, only: rk, ik
       implicit none
       integer(kind=ik), intent(out) :: status
       integer(kind=ik), intent(out) :: end_run
       real(kind=rk),    intent(out) :: new_t_delta   ! If >0, then redo step with new t_delta
       integer(kind=ik), intent(out) :: sdf_flags     ! If >0, then use bisection to solve SDF and use the result to redo step...
       integer(kind=ik), intent(in)  :: pnt_idx
       real(kind=rk),    intent(in)  :: t_y_sol(:,:), t_delta, y_delta(:)
     end subroutine stepp_iface_nt
  end interface

  !--------------------------------------------------------------------------------------------------------------------------------
  !> Type SDF function on a solution point.
  !!
  !! status .................... Exit status
  !!                              - -inf-0 .... Everything worked
  !!                              - 512-767 ... Error in this routine
  !!                              - others .... Other values are not allowed
  !! dist ...................... The distance value of the SDF funciton
  !! sdf_flags ................. Flags passed from a stepp_iface_nt routine
  !! t ......................... The t value.
  !! y(:) ...................... The y value.
  !! param(:) .................. Data payload usually used for constants.
  !!
  abstract interface
     subroutine sdf_iface_nt(status, dist, sdf_flags, t, y)
       use mrkiss_config, only: rk, ik
       implicit none
       integer(kind=ik), intent(out) :: status
       real(kind=rk),    intent(out) :: dist
       integer(kind=ik), intent(in)  :: sdf_flags
       real(kind=rk),    intent(in)  :: t, y(:)
     end subroutine sdf_iface_nt
  end interface

  public :: one_step_etab_nt, one_step_stab_nt, one_richardson_step_stab_nt
  public :: one_step_rk4_nt, one_step_rkf45_nt
  public :: steps_fixed_stab_nt
  public :: steps_condy_stab_nt
  public :: steps_adapt_etab_nt

contains

  !--------------------------------------------------------------------------------------------------------------------------------
  !> Compute one step of a embedded RK method expressed as a Butcher Tableau.
  !!
  !! Warning: No error checking on array sizes or bounds!  See: https://DOCURL/index.html#def-method
  !!
  !! status .................... Exit status
  !!                              - -inf-0 ..... Everything worked
  !!                              - 0-255 ...... Evaluation of deq failed
  !!                              - 1232-1247 .. Error in this routine
  !!                              - others ..... Other values are not allowed
  !!
  subroutine one_step_etab_nt(status, y1_delta, y2_delta, deq, y, param, a, b1, b2, c, t_delta)
    use mrkiss_config, only: rk, ik
    implicit none
    ! Arguments
    integer(kind=ik), intent(out) :: status
    real(kind=rk),    intent(out) :: y1_delta(:), y2_delta(:)
    procedure(deq_iface_nt)       :: deq
    real(kind=rk),    intent(in)  :: y(:), param(:), a(:,:), b1(:), c(:), t_delta, b2(:)
    ! Variables
    integer                       :: i, stage
    real(kind=rk)                 :: k(size(y, 1),size(a, 1)+1)
    real(kind=rk)                 :: stage_t_delta
    real(kind=rk)                 :: y_tmp(size(y, 1)), stage_y_delta(size(y, 1))
    ! Compute k vectors
    do stage=1,size(a, 1)
       stage_y_delta = 0.0_rk
       if (stage > 1) then
          do i=1,(stage-1)
             stage_y_delta = stage_y_delta + a(i,stage) * k(:,i)
          end do
       end if
       stage_t_delta = t_delta*c(stage)
       call deq(status, y_tmp, y+stage_y_delta, param)
       if (status > 0) return
       k(:,stage) = y_tmp * t_delta
    end do
    ! Compute y_delta
    y1_delta = 0.0_rk
    y2_delta = 0.0_rk
    do i=1,size(a, 1)
       y1_delta = y1_delta + k(:,i) * b1(i)
       y2_delta = y2_delta + k(:,i) * b2(i)
    end do
    status = 0
  end subroutine one_step_etab_nt

  !--------------------------------------------------------------------------------------------------------------------------------
  !> Compute one step of a non-embedded RK method expressed as a Butcher Tableau.
  !!
  !! Warning: No error checking on array sizes or bounds!  See: https://DOCURL/index.html#def-method
  !!
  !! status .................... Exit status
  !!                              - -inf-0 ..... Everything worked
  !!                              - 0-255 ...... Evaluation of deq failed
  !!                              - 1248-1263 .. Error in this routine
  !!                              - others ..... Other values are not allowed
  !!
  ! SHELLO: sed -n '/^  *subroutine one_step_etab_nt(/,/end subroutine one_step_etab_nt *$/p' mrkiss_solvers_nt.f90 | sed 's/, y2_delta[^,]*//; s/,]*//; s/_etab/_stab/; s/b1/b/g; s/y1/y/g; /y2_delta/d;'
  subroutine one_step_stab_nt(status, y_delta, deq, y, param, a, b, c, t_delta)
    use mrkiss_config, only: rk, ik
    implicit none
    ! Arguments
    integer(kind=ik), intent(out) :: status
    real(kind=rk),    intent(out) :: y_delta(:)
    procedure(deq_iface_nt)       :: deq
    real(kind=rk),    intent(in)  :: y(:), param(:), a(:,:), b(:), c(:), t_delta
    ! Variables
    integer                       :: i, stage
    real(kind=rk)                 :: k(size(y, 1),size(a, 1)+1)
    real(kind=rk)                 :: stage_t_delta
    real(kind=rk)                 :: y_tmp(size(y, 1)), stage_y_delta(size(y, 1))
    ! Compute k vectors
    do stage=1,size(a, 1)
       stage_y_delta = 0.0_rk
       if (stage > 1) then
          do i=1,(stage-1)
             stage_y_delta = stage_y_delta + a(i,stage) * k(:,i)
          end do
       end if
       stage_t_delta = t_delta*c(stage)
       call deq(status, y_tmp, y+stage_y_delta, param)
       if (status > 0) return
       k(:,stage) = y_tmp * t_delta
    end do
    ! Compute y_delta
    y_delta = 0.0_rk
    do i=1,size(a, 1)
       y_delta = y_delta + k(:,i) * b(i)
    end do
    status = 0
  end subroutine one_step_stab_nt

  !--------------------------------------------------------------------------------------------------------------------------------
  !> Compute one Richardson Extrapolation Step.
  !!
  !! Warning: No error checking on array sizes or bounds!  See: https://DOCURL/index.html#def-method
  !!
  !! status .................... Exit status
  !!                              - -inf-0 ..... Everything worked
  !!                              - 0-255 ...... Evaluation of deq failed
  !!                              - 1216-1231 .. Error in this routine
  !!                              - others ..... Other values are not allowed
  !!
  subroutine one_richardson_step_stab_nt(status, y_delta, deq, y, param, a, b, c, p, t_delta)
    use mrkiss_config, only: rk, ik
    implicit none
    ! Arguments
    integer(kind=ik), intent(out) :: status
    real(kind=rk),    intent(out) :: y_delta(:)
    procedure(deq_iface_nt)       :: deq
    real(kind=rk),    intent(in)  :: y(:), param(:), a(:,:), b(:), c(:)
    integer(kind=ik), intent(in)  :: p
    real(kind=rk),    intent(in)  :: t_delta
    ! Variables
    real(kind=rk)                 :: t_delta_tmp, t_tmp, y_tmp(size(y, 1))
    real(kind=rk)                 :: y_delta_small_1(size(y, 1)), y_delta_small_2(size(y, 1)), y_delta_big(size(y, 1))
    ! Compute y_delta_big
    call one_step_stab_nt(status, y_delta_big, deq, y, param, a, b, c, t_delta)
    if (status > 0) return
    ! Compute y_delta_small
    t_delta_tmp = t_delta / 2.0_rk
    t_tmp       = 0.0_rk
    y_tmp       = y
    call one_step_stab_nt(status, y_delta_small_1, deq, y_tmp, param, a, b, c, t_delta_tmp)
    if (status > 0) return
    t_tmp = t_tmp + t_delta_tmp
    y_tmp = y_tmp + y_delta_small_1
    call one_step_stab_nt(status, y_delta_small_2, deq, y_tmp, param, a, b, c, t_delta_tmp)
    if (status > 0) return
    ! Compute y_delta
    y_delta = y_delta_small_1 + y_delta_small_2 + (y_delta_small_1 + y_delta_small_2 - y_delta_big) / (2**p - 1)
    status = 0
  end subroutine one_richardson_step_stab_nt

  !--------------------------------------------------------------------------------------------------------------------------------
  !> Compute one step of RK (mrkiss_erk_kutta_4)
  !!
  !! status .................... Exit status
  !!                              - -inf-0 ..... Everything worked
  !!                              - 0-255 ...... Evaluation of deq failed
  !!                              - 1200-1215 .. Error in this routine
  !!                              - others ..... Other values are not allowed
  !!
  subroutine one_step_rk4_nt(status, y_delta, deq, y, param, t_delta)
    use mrkiss_config, only: rk, ik
    implicit none
    ! Arguments
    integer(kind=ik), intent(out) :: status
    real(kind=rk),    intent(out) :: y_delta(:)
    procedure(deq_iface_nt)       :: deq
    real(kind=rk),    intent(in)  :: y(:), param(:), t_delta
    ! Variables
    real(kind=rk)                 :: k1(size(y, 1)), k2(size(y, 1)), k3(size(y, 1)), k4(size(y, 1))
    ! Compute Step
    call deq(status, k1, y, param)
    if (status > 0) return
    call deq(status, k2, y + 1.0_rk/2.0_rk * t_delta * k1, param)
    if (status > 0) return
    call deq(status, k3, y + 1.0_rk/2.0_rk * t_delta * k2, param)
    if (status > 0) return
    call deq(status, k4, y + t_delta * k3, param)
    y_delta = t_delta * (k1 + 2.0_rk * k2 + 2.0_rk * k3 + k4) / 6.0_rk
    status = 0
  end subroutine one_step_rk4_nt

  !--------------------------------------------------------------------------------------------------------------------------------
  !> Compute one step of RKF45 (mrkiss_eerk_fehlberg_4_5)
  !!
  !! status .................... Exit status
  !!                              - -inf-0 ..... Everything worked
  !!                              - 0-255 ...... Evaluation of deq failed
  !!                              - 1184-1199 .. Error in this routine
  !!                              - others ..... Other values are not allowed
  !!
  subroutine one_step_rkf45_nt(status, y1_delta, y2_delta, deq, y, param, t_delta)
    use mrkiss_config, only: rk, ik
    implicit none
    ! Arguments
    integer(kind=ik), intent(out) :: status
    real(kind=rk),    intent(out) :: y1_delta(:), y2_delta(:)
    procedure(deq_iface_nt)       :: deq
    real(kind=rk),    intent(in)  :: y(:), param(:), t_delta
    ! Variables
    real(kind=rk)                 :: k1(size(y, 1)), k2(size(y, 1)), k3(size(y, 1))
    real(kind=rk)                 :: k4(size(y, 1)), k5(size(y, 1)), k6(size(y, 1))
    ! Compute Step
    call deq(status, k1, y, param)
    if (status > 0) return
    call deq(status, k2, y + 1.0_rk/4.0_rk * t_delta * k1, param)
    if (status > 0) return
    call deq(status, k3, y + t_delta * (3.0_rk/32.0_rk * k1 + 9.0_rk/32.0_rk * k2), param)
    if (status > 0) return
    call deq(status, k4, y + t_delta * (1932.0_rk/2197.0_rk * k1 - 7200.0_rk/2197.0_rk * k2 + 7296.0_rk/2197.0_rk * k3), param)
    if (status > 0) return
    call deq(status, k5, y + t_delta * (439.0_rk/216.0_rk * k1 - 8.0_rk * k2 + 3680.0_rk/513.0_rk * k3 - 845.0_rk/4104.0_rk * k4), param)
    if (status > 0) return
    call deq(status, k6, y + t_delta * (-8.0_rk/27.0_rk * k1 + 2.0_rk * k2 - 3544.0_rk/2565.0_rk * k3 + 1859.0_rk/4104.0_rk * k4 - 11.0_rk/40.0_rk * k5), param)
    if (status > 0) return
    y1_delta = t_delta * (25.0_rk/216.0_rk * k1 + 1408.0_rk/2565.0_rk * k3 + 2197.0_rk/4104.0_rk * k4 - 1.0_rk/5.0_rk * k5)
    y2_delta = t_delta * (16.0_rk/135.0_rk * k1 + 6656.0_rk/12825.0_rk * k3 + 28561.0_rk/56430.0_rk * k4 - 9.0_rk/50.0_rk * k5 + 2.0_rk/55.0_rk * k6)
    status = 0
  end subroutine one_step_rkf45_nt

  !--------------------------------------------------------------------------------------------------------------------------------
  !> Take multiple fixed steps.
  !!
  !! Computes fixed steps and stores solutions in t_y_sol.  In the absence of errors, t_y_sol will be completely filled.  If a
  !! non-zero status is returned, then the first element istats may be consulted to determine how many solutions t_y_sol
  !! contains.
  !!
  !! status .................... Exit status
  !!                              - -inf-0 ..... Everything worked
  !!                              - 0-255 ...... Evaluation of deq failed
  !!                              - 1120-1151 .. Error in this routine
  !!                              - others ..... Other values are not allowed
  !! istats(:) ................. Integer statistics for run
  !! t_y_sol(:,:) .............. Array for solution.  Must have ((size(t_y_sol, 1) == size(y, 1) + 1) .and. (size(t_y_sol, 2) > 1))
  !!                              Each COLUMN is a solution.  
  !!                              The first element of each solution is the t variable.  The remaining values are the elements of y.
  !!                              The number of columns, and max_pts_o, determin the number of solution points.
  !! deq ....................... Equation subroutine
  !! t, y(:) ................... Initial conditions.  y is a column vector!
  !! param(:) .................. Data payload passed to deq
  !! a(:,:), b(:), c(:) ........ The butcher tableau
  !! p_o ....................... The order for the RK method in the butcher tableau (if provided enables Richardson extrapolation)
  !! max_pts_o ................. Maximum number of solutions to put in t_y_sol.
  !! t_delta_o ................. Step size to use.  
  !!                             If t_end_o is provided:  Default: (t_end - t) / (size(t_y_sol, 2) - 1)
  !!                             If t_end_o not provided: Default: mrkiss_config::t_delta_ai
  !! t_end_o ................... End point for last step.  Silently ignored if t_delta_o is provided.
  !!
  subroutine steps_fixed_stab_nt(status, istats, t_y_sol, deq, y, param, a, b, c, p_o, max_pts_o, t_delta_o, t_end_o)
    use mrkiss_config, only: rk, ik, t_delta_ai
    implicit none
    ! Arguments
    integer(kind=ik),           intent(out) :: status, istats(16)
    real(kind=rk),              intent(out) :: t_y_sol(:,:)
    procedure(deq_iface_nt)                 :: deq
    real(kind=rk),              intent(in)  :: y(:), param(:), a(:,:), b(:), c(:)
    integer(kind=ik), optional, intent(in)  :: p_o, max_pts_o
    real(kind=rk),    optional, intent(in)  :: t_delta_o, t_end_o
    ! Vars
    integer                                 :: cur_pnt_idx, max_pts
    real(kind=rk)                           :: t_cv, t_delta
    real(kind=rk)                           :: y_cv(size(y, 1)), y_delta(size(y, 1))
    ! Process arguments
    max_pts = size(t_y_sol, 2)
    if (present(max_pts_o)) max_pts = min(max_pts, max_pts_o);
    if (present(t_delta_o)) then
       t_delta = t_delta_o
    else 
       if (present(t_end_o)) then
          t_delta = (t_end_o - 0.0_rk) / (size(t_y_sol, 2) - 1)
       else
          t_delta = t_delta_ai
       end if
    end if
    ! Compute solution
    istats = 0
    t_cv = 0.0_rk
    y_cv = y
    t_y_sol(1,  1) = t_cv
    t_y_sol(2:, 1) = y_cv
    istats(1) = istats(1) + 1
    do cur_pnt_idx=2,max_pts
       if (present(p_o)) then
          call one_richardson_step_stab_nt(status, y_delta, deq, y_cv, param, a, b, c, p_o, t_delta)
          istats(2) = istats(2) + 3
       else
          call one_step_stab_nt(status, y_delta, deq, y_cv, param, a, b, c, t_delta)
          istats(2) = istats(2) + 1
       end if
       if (status > 0) return
       y_cv = y_cv + y_delta
       t_cv = t_cv + t_delta
       t_y_sol(1, cur_pnt_idx) = t_cv
       t_y_sol(2:, cur_pnt_idx) = y_cv
       istats(1) = istats(1) + 1
    end do
    status = 0;
  end subroutine steps_fixed_stab_nt

  !--------------------------------------------------------------------------------------------------------------------------------
  !> Take multiple adaptive steps with a simple RK method to achieve constant length y_delta steps.
  !!
  !! The t_y_sol matrix might not be completely filled upon return:
  !!   - A step failed because a t_delta couldn't be found that produces the required y_delta_len_targ.
  !!   - A step failed because deq returned an error.
  !!   - The routine ended because the length of the solution has grown longer than y_sol_len_max_o
  !! Note the first two conditions will generate an error, non-zero status; however, the third item is a clean exit with status
  !! equal to zero.  Therefore the value of istats(1) should always be consulted to determine the number of solutions in t_y_sol.
  !!
  !! The adaptive step size is controlled to result in steps that achieve a constant "length".  The "length" is defined to be the
  !! Euclidean norm of the subset of the solution vector specified by y_delta_len_idxs_o.  For each solution the routine will
  !! make two one_step_stab_* calls with t_delta_min_o and t_delta_max, and then use bisection (with additional calls to
  !! one_step_stab_*) to isolate a t_delta value that leads to a a length within y_delta_len_tol_o of y_delta_len_targ.
  !!     
  !! Note there is no mathematical guarantee that a RK step of size t_delta_min_o and t_delta_max will produce solutions that
  !! bracket y_delta_len_targ.  That said, for well behaved functions a t_delta_min_o and t_delta_max may always be found that
  !! work.  In practice finding good values are t_delta_min_o and t_delta_max isn't normally difficult.  One approach for harder
  !! problems is to use fixed step sizes over the interval in question, and then examine the y_delta lengths in the solution.
  !!
  !! With some care and effort, fixed y step size can be achieved via steps_adapt_etab_nt.  This function is both easier to use
  !! and faster.
  !!
  !! My primary use case for this function is to create uniform sphere sweeps for constructive solid geometry applications.
  !!
  !! status .................... Exit status
  !!                              - -inf-0 ..... Everything worked
  !!                              - 0-255 ...... Evaluation of deq failed
  !!                              - 1024-1055 .. Error in this routine
  !!                                              - 1024 .. t_delta_min yielded a longer step than t_delta_max
  !!                                              - 1025 .. More than max_bisections were performed during a step
  !!                              - others ..... Other values are not allowed
  !! istats(:) ................. Integer statistics for run
  !! t_y_sol ................... Array for solution.  Must have ((size(t_y_sol, 1) == size(y, 1) + 1) .and. (size(t_y_sol, 2) > 1))
  !!                              Each COLUMN is a solution.  
  !!                              The first element of each solution is the t variable.  The remaining values are the elements of y.
  !!                              The number of columns, and max_pts_o, determin the number of solution points.
  !! deq ....................... Equation subroutine
  !! t, y(:) ................... Initial conditions.  y is a column vector!
  !! param(:) .................. Data payload passed to deq
  !! a(:,:), b(:), c(:) ........ The butcher tableau
  !! y_delta_len_targ .......... Attempt to make all steps this long
  !! t_delta_max ............... Maximum t_delta
  !! t_delta_min_o ............. Minimum t_delta
  !! y_delta_len_tol_o ......... How close we have to get to y_delta_len_targ.  Default is y_delta_len_targ/100
  !! y_delta_len_idxs_o ........ Components of y_delta to use for y_delta length computation
  !! max_pts_o ................. Maximum number of solutions to put in t_y_sol.
  !! max_bisections_o .......... Maximum number of bisection iterations to perform for each step.  Default: max_bisections_ai
  !! y_sol_len_max_o ........... Maximum length of the solution curve
  !! t_max_o ................... Maximum value for t
  !!
  subroutine steps_condy_stab_nt(status, istats, t_y_sol, deq, y, param, a, b, c, y_delta_len_targ, t_delta_max, t_delta_min_o, y_delta_len_tol_o, max_bisections_o, y_delta_len_idxs_o, max_pts_o, y_sol_len_max_o, t_max_o)
    use mrkiss_config, only: rk, ik, t_delta_tiny, max_bisections_ai
    implicit none
    ! Arguments
    integer(kind=ik),           intent(out) :: status, istats(16)
    real(kind=rk),              intent(out) :: t_y_sol(:,:)
    procedure(deq_iface_nt)                 :: deq
    real(kind=rk),              intent(in)  :: y(:), param(:), a(:,:), b(:), c(:), y_delta_len_targ, t_delta_max
    real(kind=rk),    optional, intent(in)  :: t_delta_min_o, y_delta_len_tol_o
    integer(kind=ik), optional, intent(in)  :: max_pts_o, max_bisections_o, y_delta_len_idxs_o(:)
    real(kind=rk),    optional, intent(in)  :: y_sol_len_max_o, t_max_o
    ! Variables
    integer(kind=ik)                        :: max_bisections
    integer                                 :: max_pts, cur_pnt_idx, biter
    real(kind=rk)                           :: y_delta_tol, t_delta_min, y_sol_len
    real(kind=rk)                           :: t_cv, t_delta_min_tmp, t_delta_max_tmp, y_delta_min_length, y_delta_max_length, y_delta_cur_length, t_delta_cur
    real(kind=rk)                           :: y_cv(size(y, 1)), y_delta(size(y, 1)), y_delta_min(size(y, 1)), y_delta_max(size(y, 1)), y_delta_cur(size(y, 1))
    ! Process arguments
    max_pts = size(t_y_sol, 2)
    if (present(max_pts_o)) max_pts = min(max_pts, max_pts_o);
    t_delta_min = t_delta_tiny
    if (present(t_delta_min_o)) t_delta_min = t_delta_min_o
    max_bisections = max_bisections_ai
    if (present(max_bisections_o)) max_bisections = max_bisections_o
    y_delta_tol = y_delta_len_targ / 100.0_rk
    if (present(y_delta_len_tol_o)) y_delta_tol = y_delta_len_tol_o
    ! Compute Solution
    y_sol_len = 0.0_rk
    istats = 0
    t_cv = 0.0_rk
    y_cv = y
    t_y_sol(1,  1) = t_cv
    t_y_sol(2:, 1) = y_cv
    istats(1) = istats(1) + 1
    do cur_pnt_idx=2,max_pts
       t_delta_min_tmp = t_delta_min
       t_delta_max_tmp = t_delta_max
       call one_step_stab_nt(status, y_delta_min, deq, y_cv, param, a, b, c, t_delta_min_tmp)
       istats(2) = istats(2) + 1
       if (status > 0) return
       if (present(y_delta_len_idxs_o)) then
          y_delta_min_length = norm2(y_delta_min(y_delta_len_idxs_o))
       else
          y_delta_min_length = norm2(y_delta_min)
       end if
       call one_step_stab_nt(status, y_delta_max, deq, y_cv, param, a, b, c, t_delta_max_tmp)
       istats(2) = istats(2) + 1
       if (status > 0) return
       if (present(y_delta_len_idxs_o)) then
          y_delta_max_length = norm2(y_delta_max(y_delta_len_idxs_o))
       else
          y_delta_max_length = norm2(y_delta_max)
       end if
       if ((y_delta_min_length < y_delta_len_targ) .and. (y_delta_max_length > y_delta_len_targ)) then
          t_delta_cur        = t_delta_max_tmp
          y_delta_cur_length = y_delta_max_length
          biter              = 1
          do while (abs(y_delta_max_length - y_delta_min_length) > y_delta_tol)
             t_delta_cur = (t_delta_max_tmp + t_delta_min_tmp) / 2.0_rk
             call one_step_stab_nt(status, y_delta_cur, deq, y_cv, param, a, b, c, t_delta_cur)
             istats(3) = istats(3) + 1
             if (status > 0) return
             y_delta_cur_length = norm2(y_delta_cur)
             if (present(y_delta_len_idxs_o)) then
                y_delta_cur_length = norm2(y_delta_cur(y_delta_len_idxs_o))
             else
                y_delta_cur_length = norm2(y_delta_cur)
             end if
             if (y_delta_cur_length < y_delta_len_targ) then
                y_delta_min_length = y_delta_cur_length
                t_delta_min_tmp = t_delta_cur
             else
                y_delta_max_length = y_delta_cur_length
                t_delta_max_tmp = t_delta_cur
             end if
             if (biter >  max_bisections) then
                status = 1025
                return
             end if
             biter = biter + 1;
          end do
          y_cv = y_cv + y_delta_cur
          t_cv = t_cv + t_delta_cur
          t_y_sol(1, cur_pnt_idx) = t_cv
          t_y_sol(2:, cur_pnt_idx) = y_cv
          istats(1) = istats(1) + 1
          y_sol_len = y_sol_len + y_delta_cur_length
          if (present(y_sol_len_max_o)) then
             if (y_sol_len > y_sol_len_max_o) then
                status = 0
                return
             end if
          end if
          if (present(t_max_o)) then
             if (t_cv > t_max_o) then
                status = 0
                return
             end if
          end if
       else
          status = 1024
          return
       end if
    end do
    status = 0
  end subroutine steps_condy_stab_nt

  !--------------------------------------------------------------------------------------------------------------------------------
  !> Take multiple adaptive steps with an embedded RK method using a relatively traditional step size controls.
  !!
  !! Modes:
  !!  - Always adpat on every step
  !!  - Never adapt -- like steps_fixed_stab_nt()
  !!  - Adapt for fixed size y_delta -- like steps_condy_stab_nt()
  !!
  !! status .................... Exit status
  !!                              - -inf-0 ..... Everything worked
  !!                              - 0-255 ...... Evaluation of deq failed
  !!                              - 256-511 .... Error in stepp_o
  !!                              - 512-767 .... Error in sdf_o
  !!                              - 1056-1119 .. Error in this routine
  !!                              - others ..... Other values are not allowed
  !! istats(:) ................. Integer statstics for run
  !! t_y_sol(:,:) .............. Array for solution.
  !!                              Each COLUMN is a solution.
  !!                              The first element of each solution is the t variable with rest the elements of y.
  !!                              The number of columns, and max_pts_o, determin the number of solution points.
  !! deq ....................... Equation subroutine
  !! t, y(:) ................... Initial conditions.  y is a column vector!
  !! param(:) .................. Data payload passed to deq
  !! a(:), b1(:), b2(:), c(:) .. The butcher tableau
  !! p1, p2 .................... The orders for the RK methods in the butcher tableaus
  !! t_max_o ................... Stop if t>t_max_o.  Diffrent from t_end_o! Default: NONE
  !! t_end_o ................... Try to stop integration at t_end. Default: NONE
  !! t_delta_ini_o ............. Initial t_delta. Default: (t_delta_max_o+t_delta_min_o)/2 if t_delta_max_o is present, and t_delta_ai otherwise
  !! t_delta_min_o ............. Minimum allowed t_delta. Default: t_delta_tiny
  !! t_delta_max_o ............. Maximum allowed t_delta. Default: NONE
  !! t_delta_fac_min_o ......... Minimum t_delta adaption factor for all but the first step.  Default:  t_delta_fac_min_ai
  !! t_delta_fac_max_o ......... Maximum t_delta adaption factor.  Default:  2.0_rk
  !! t_delta_fac_fdg_o ......... Extra t_delta adaption factor when shrinking interval. Default: t_delta_fac_fdg_ai
  !! error_tol_abs_o(:) ........ Absolute error tolerance. Default: error_tol_abs_ai
  !! error_tol_rel_o(:) ........ Relative error tolerance. Default: error_tol_rel_ai
  !! max_pts_o ................. Maximum number of solutions to put in t_y_sol.
  !! max_bisections_o .......... Maximum number of bisection iterations to perform for each step. Default: max_bisections_ai
  !! sdf_o ..................... SDF function.  Used to set new t_delta for a step.  This subroutine may trigger one or
  !!                             more of the follwoing actions:
  !!                              - status>0      => Immediately returns without doing anything else propagating status to caller.
  !!                                                 Positive status values must come from the interval [256, 511].
  !!                              - new_t_delta>0 => Recompute y_delta using new_t_delta.
  !!                              - sdf_flags>0   => Redo step with a t_delta derived from the sdf_o via bisection.
  !!                              - end_run>0     => routine returns after this step is complete.
  !! sdf_tol_o ................. How close we have to get to accept an sdf solution. Default: sdf_tol_ai
  !! stepp_o ................... Step processing subroutine.  Called after each step.
  !! 
  subroutine steps_adapt_etab_nt(status, istats, t_y_sol, deq, y, param, a, b1, b2, c, p1, p2, t_max_o, t_end_o, t_delta_ini_o, &
                                 t_delta_min_o, t_delta_max_o, t_delta_fac_min_o, t_delta_fac_max_o, t_delta_fac_fdg_o,            &
                                 error_tol_abs_o, error_tol_rel_o, max_pts_o, max_bisections_o, sdf_o, sdf_tol_o, stepp_o)
    use mrkiss_config
    implicit none
    ! Arguments
    integer(kind=ik),                    intent(out) :: status, istats(16)
    real(kind=rk),                       intent(out) :: t_y_sol(:,:)
    procedure(deq_iface_nt)                          :: deq
    real(kind=rk),                       intent(in)  :: y(:), param(:), a(:,:), b1(:), b2(:), c(:)
    integer(kind=ik),                    intent(in)  :: p1, p2
    real(kind=rk),             optional, intent(in)  :: t_max_o, t_end_o, t_delta_ini_o, t_delta_min_o, t_delta_max_o
    real(kind=rk),             optional, intent(in)  :: t_delta_fac_min_o, t_delta_fac_max_o, t_delta_fac_fdg_o
    real(kind=rk),             optional, intent(in)  :: error_tol_abs_o(:), error_tol_rel_o(:)
    integer(kind=ik),          optional, intent(in)  :: max_pts_o, max_bisections_o
    procedure(sdf_iface_nt),   optional              :: sdf_o
    real(kind=rk),             optional, intent(in)  :: sdf_tol_o
    procedure(stepp_iface_nt), optional              :: stepp_o
    ! Variables
    integer                                          :: max_pts, cur_pnt_idx, i, adj_cnt
    real(kind=rk)                                    :: t_delta_fac, t_nxt, y_cv(size(y, 1)), y1_delta(size(y, 1))
    real(kind=rk)                                    :: y2_delta(size(y, 1)), y_nxt(size(y, 1)), t_delta_ini, t_delta_min
    real(kind=rk)                                    :: t_delta_max, y_delta_delta(size(y, 1)), t_delta_fac_max, t_delta_fac_min
    real(kind=rk)                                    :: t_delta_fac_fdg, t_delta_nxt, sdf_tol, error_tol_abs(size(y, 1))
    real(kind=rk)                                    :: error_tol_rel(size(y, 1)), comb_err_tol(size(y, 1)), t_cv, t_delta
    real(kind=rk)                                    :: sp_new_t_delta, bs_tmp1_t_delta, bs_tmp2_t_delta, bs_tmp_t_delta
    real(kind=rk)                                    :: bs_tmp_y_delta(size(y, 1)), bs_tmp1_dist, bs_tmp2_dist, bs_tmp_dist
    logical                                          :: t_delta_end_p
    integer(kind=ik)                                 :: max_bisections, sp_end_run, sp_sdf_flags, bs_itr
    ! Process arguments
    error_tol_abs = error_tol_abs_ai
    if (present(error_tol_abs_o)) then
       if (size(error_tol_abs_o, 1) < size(y, 1)) then
          error_tol_abs = error_tol_abs_o(1)
       else
          error_tol_abs = error_tol_abs_o
       end if
    end if
    error_tol_rel = error_tol_rel_ai
    if (present(error_tol_rel_o)) then
       if (size(error_tol_rel_o, 1) < size(y, 1)) then
          error_tol_rel = error_tol_rel_o(1)
       else
          error_tol_rel = error_tol_rel_o
       end if
    end if
    sdf_tol = sdf_tol_ai
    if (present(sdf_tol_o)) sdf_tol = sdf_tol_o
    t_delta_fac_fdg = t_delta_fac_fdg_ai
    if (present(t_delta_fac_fdg_o))  t_delta_fac_fdg = t_delta_fac_fdg_o
    max_bisections = max_bisections_ai
    if (present(max_bisections_o)) max_bisections = max_bisections_o
    t_delta_fac_max = t_delta_fac_max_ai
    if (present(t_delta_fac_max_o)) t_delta_fac_max = t_delta_fac_max_o
    t_delta_fac_min = t_delta_fac_min_ai
    if (present(t_delta_fac_min_o)) t_delta_fac_min = t_delta_fac_min_o
    t_delta_min = t_delta_tiny
    if (present(t_delta_min_o)) t_delta_min = t_delta_min_o
    if (present(t_delta_ini_o)) then
       t_delta_ini = t_delta_ini_o
    else 
       t_delta_ini = t_delta_ai
       if (present(t_delta_max_o))  t_delta_ini = (t_delta_max_o - t_delta_min) / 2
    end if
    max_pts = size(t_y_sol, 2)
    if (present(max_pts_o)) max_pts = min(max_pts, max_pts_o);
    ! Compute solution
    istats = 0
    t_delta = t_delta_ini
    t_cv = 0.0_rk
    y_cv = y
    t_y_sol(1,  1) = t_cv
    t_y_sol(2:, 1) = y_cv
    istats(1) = istats(1) + 1
    do cur_pnt_idx=2,max_pts
       ! If close to the end, adjust t_delta to hit t_end_o
       t_delta_end_p = .false.
       if (present(t_end_o)) then
          if (t_cv+t_delta*1.10_rk >= t_end_o) then
             t_delta = t_end_o - t_cv
             t_delta_end_p = .true.
          end if
       end if
       ! Do step and adaptive step
       do adj_cnt=1,2
          call one_step_etab_nt(status, y1_delta, y2_delta, deq, y_cv, param, a, b1, b2, c, t_delta)
          if (adj_cnt > 1) then
             istats(4) = istats(4) + 1
          else
             istats(2) = istats(2) + 1
          end if
          if (status > 0) return
          ! Compute new t_delta_nxt based on error estimate.
          y_delta_delta = abs(y1_delta-y2_delta)
          comb_err_tol  = (error_tol_rel + max(abs(t_y_sol(2:, cur_pnt_idx-1)), abs(y_cv + y1_delta)) * error_tol_rel)
          ! MJR TODO NOTE steps_adapt_etab_nt: Fix this for when comb_err_tol has a zero entry!
          t_delta_fac   = (1/sqrt(sum((y_delta_delta / comb_err_tol) ** 2) / size(y, 1))) ** (1 + 1/min(p1, p2))
          if (t_delta_fac < 1.0_rk)  t_delta_fac = t_delta_fac * t_delta_fac_fdg
          if (cur_pnt_idx /= 2)      t_delta_fac = max(t_delta_fac_min, t_delta_fac)
          t_delta_fac = min(t_delta_fac_max, t_delta_fac)
          t_delta_nxt = t_delta * t_delta_fac
          if (present(t_delta_min_o)) then
             t_delta_nxt = max(t_delta_min_o, t_delta_nxt)
          end if
          if (present(t_delta_max_o)) then
             t_delta_nxt = min(t_delta_max_o, t_delta_nxt)
          end if
          ! Break out of loop if all is good.
          if (all(y_delta_delta <= comb_err_tol)) exit
          ! Redoing step
          t_delta = t_delta_nxt
          t_delta_end_p = .false.
          ! When redoing a step close to t_end_o, we don't want t_delta to get us more than half way to t_end_o
          if (present(t_end_o)) then
             if (t_cv + t_delta * 2 >= t_end_o) then
                t_delta = (t_end_o - t_cv) / 2.0_rk
             end if
          end if
       end do
       if (present(stepp_o)) then
          call stepp_o(status, sp_end_run, sp_sdf_flags, sp_new_t_delta, cur_pnt_idx, t_y_sol, t_delta, y1_delta)
          if (sp_new_t_delta > 0) then
             if (present(t_delta_min_o)) then
                sp_new_t_delta = max(t_delta_min_o, sp_new_t_delta)
             end if
             if (present(t_delta_max_o)) then
                sp_new_t_delta = min(t_delta_max_o, sp_new_t_delta)
             end if
             t_delta = sp_new_t_delta ! Leave t_delta_nxt unchanged...
             call one_step_stab_nt(status, y1_delta, deq, y_cv, param, a, b1, c, t_delta)
             istats(5) = istats(5) + 1
          end if
          if (sp_sdf_flags > 0) then
             bs_tmp1_t_delta = t_delta_min
             call one_step_stab_nt(status, bs_tmp_y_delta, deq, y_cv, param, a, b1, c, bs_tmp1_t_delta)
             istats(6) = istats(6) + 1
             if (status > 0) return
             call sdf_o(status, bs_tmp1_dist, sp_sdf_flags, t_cv+bs_tmp1_t_delta, y_cv+bs_tmp_y_delta)
             if (status > 0) return
             bs_tmp2_t_delta = t_delta
             call one_step_stab_nt(status, bs_tmp_y_delta, deq, y_cv, param, a, b1, c, bs_tmp2_t_delta)
             istats(6) = istats(6) + 1
             if (status > 0) return
             call sdf_o(status, bs_tmp2_dist, sp_sdf_flags, t_cv+bs_tmp2_t_delta, y_cv+bs_tmp_y_delta)
             if (status > 0) return
             if (bs_tmp2_dist < bs_tmp1_dist) then ! Swap if req. 
                bs_tmp_t_delta  = bs_tmp1_t_delta
                bs_tmp1_t_delta = bs_tmp2_t_delta
                bs_tmp2_t_delta = bs_tmp_t_delta
                bs_tmp_dist     = bs_tmp1_dist
                bs_tmp1_dist    = bs_tmp2_dist
                bs_tmp2_dist    = bs_tmp_dist
             end if
             if (bs_tmp2_dist >= 0) then ! We don't exit if we can't bisect, we just don't do it.
                bs_itr = 1
                do 
                   bs_tmp_t_delta = (bs_tmp1_t_delta + bs_tmp2_t_delta) / 2.0_rk
                   call one_step_stab_nt(status, bs_tmp_y_delta, deq, y_cv, param, a, b1, c, bs_tmp_t_delta)
                   istats(6) = istats(6) + 1
                   if (status > 0) return
                   call sdf_o(status, bs_tmp_dist, sp_sdf_flags, t_cv+bs_tmp_t_delta, y_cv+bs_tmp_y_delta)
                   if (status > 0) return
                   if (abs(bs_tmp_dist) <= sdf_tol) exit
                   if (bs_tmp_dist < 0.0_rk) then
                      bs_tmp1_t_delta = bs_tmp_t_delta
                      bs_tmp1_dist    = bs_tmp_dist
                   else
                      bs_tmp2_t_delta = bs_tmp_t_delta
                      bs_tmp2_dist    = bs_tmp_dist
                   end if
                   bs_itr = bs_itr + 1;
                   if (bs_itr > max_bisections) then
                      status = 1025
                      return
                   end if
                end do
                t_delta  = bs_tmp_t_delta
                y1_delta = bs_tmp_y_delta
             end if
          end if
       end if
       y_cv = y_cv + y1_delta
       t_cv = t_cv + t_delta
       t_delta = t_delta_nxt
       t_y_sol(1,  cur_pnt_idx) = t_cv
       t_y_sol(2:, cur_pnt_idx) = y_cv
       istats(1) = istats(1) + 1
       if (present(stepp_o)) then
          if (sp_end_run > 0) then
             return ! If we get here, then status was set by stepp_o
          end if
       end if
       if (present(t_max_o)) then
          if (t_cv > t_max_o) exit
       end if
       if (t_delta_end_p) exit
    end do
    status = 0;
  end subroutine steps_adapt_etab_nt

end module mrkiss_solvers_nt



